<doctype html>
<!-- Cameron Christensen - Fall '20 -->
<!-- Visualization of Lambertian reflections as described in Peter Shirley's "Ray Tracing in One Weekend" -->
<!-- Adapted from cs4600 b-splines example from Cem Yuksel (thanks!)-->
<!-- <self-deprecation> Maybe somebody has done this already, and likely better. I just wanted to better understand and compare these algorithms for Lambertian reflection. This is my first use of jquery and svg. This is clearly hacky. I just wrote quick Vec and Ray classes because I was too lazy to cut and paste anything, much less find a module to import, then learn how to use it--I just wanted to see some lines, remember? Plus xxXxXx has traumitized me so much that I now avoid ever wanting to use anyone else's libraries ever again. Yes, I'm going to share this, and I don't want to be judged on this crap code, but it's still cool to press a couple keys to see the differences between these methods clearly illustrated. </self-deprecation> -->
<html>
<head>
<title>Lambertian reflection visualization</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<script type="text/javascript">

 class Vec {
     x;
     y;
	   constructor(_x,_y)
	   {
         this.x=_x;
         this.y=_y;
     }

     dot(other) { return this.x*other.x + this.y*other.y; }
	   len_squared() { return this.dot(this); }
	   len() { return Math.sqrt(this.len_squared()); }
     normalize() {
         var l = this.len();
         this.x /= l;
         this.y /= l;
     }
     plus(other) { return new Vec(this.x+other.x, this.y+other.y); }
     sub(other) { return new Vec(this.x-other.x, this.y-other.y); }
     mul(t) { return new Vec(this.x*t, this.y*t); }
 }

 class Ray {
     o;
     v;
	   constructor(_o,_v)
	   {
         this.o=_o;
         this.v=_v;
         //this.v.normalize();
     }

     at(t) { return this.o.plus(this.v.mul(t)); }
 }

 // Called once to initialize
 function InitCanvas()
 {
	   // Initialize the WebGL canvas
	   const canvas = document.getElementById("canvas");
	   canvas.oncontextmenu = function() {return false;};

	   // Set the viewport size
	   UpdateCanvasSize();
 }

 // Called every time the window size is changed.
 function UpdateCanvasSize()
 {
	   const canvas = document.getElementById("canvas");
	   canvas.style.width  = '100%';
	   canvas.style.height = '100%';
	   const pixelRatio = window.devicePixelRatio || 1;
	   canvas.width  = pixelRatio * canvas.clientWidth;
	   canvas.height = pixelRatio * canvas.clientHeight;
	   const width  = (canvas.width  / pixelRatio);
	   const height = (canvas.height / pixelRatio);
	   canvas.style.width  = width  + 'px';
	   canvas.style.height = height + 'px';
 }

 function ClearScene()
 {
     const overlay = document.getElementById("overlay");
     while (overlay.firstChild) {
         overlay.removeChild(overlay.firstChild);
     }
 }

 function GenerateScene()
 {
     const overlay = document.getElementById("overlay");

	   var w = document.documentElement.clientWidth;
	   var h = document.documentElement.clientHeight;
     var normlen = normlen_pct * h;
     pt[1] = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
     pt[2] = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
     pt[3] = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
     overlay.appendChild(pt[1]);
     overlay.appendChild(pt[2]);
     overlay.appendChild(pt[3]);

     // put a big sphere in there as the object having been struck by the ray
     var s = h*k_pct_sides;
     var r = s/2.0 + w*w/(8.0*s); // https://www.mathopenref.com/arcradiusderive.html
     //console.log("r: " + r);
	   pt[1].setAttribute("r", r);
	   pt[1].setAttribute("cy", h + r - h*k_pct);
	   pt[1].setAttribute("cx", 0.5*w);
	   pt[1].setAttribute("fill", "red");

     // unit cirle at hit point
     var c = [.5*w, h*(1.0-k_pct - normlen_pct)];
	   pt[2].setAttribute("cx", c[0]);
	   pt[2].setAttribute("cy", c[1]);
	   pt[2].setAttribute("r", normlen);
	   pt[2].setAttribute("fill", "none");

     // mole
	   pt[3].setAttribute("cx", .9*w);
	   pt[3].setAttribute("cy", .85*h);
	   pt[3].setAttribute("r", 7);
	   pt[3].setAttribute("fill", "black");

     // generate some lines of reflection
     if (!from_circle) {
         var p = [0.5*w, h*(1.0-k_pct)]; // hit point from which reflection will begin
     }
     else { var p = c; }// visualize from center of unit circle
     //console.log("origin: " + p[0] +", "+p[1]);
     for (i=0; i<nsamples; i++) {
         do {
             var x = Math.random()*2.0 - 1.0;
             var y = Math.random()*2.0 - 1.0;
         } while ((x*x + y*y) > 1.0);
         sample = new Vec(x,y);
         //console.log("sample: " + sample.x + ", " + sample.y);

         // to better simulate Lambertian, normalize the sample to the edge of the circle
         if (better_sampling) {
             sample.normalize();
         }

         // throw in some cute colored pts to show where the sample comes from
         var point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
         point.setAttribute('cx',c[0]+normlen*sample.x);
         point.setAttribute('cy',c[1]+normlen*sample.y);
         point.setAttribute("r", 5)
         point.setAttribute("stroke", "lightgreen")
         point.setAttribute("stroke", "lightgreen")
         point.setAttribute("fill", "lightgreen")
         overlay.appendChild(point);

         if (from_circle) {
             ray = new Ray(new Vec(p[0], p[1]), sample);
         }
         else {
             rvec = new Vec(c[0]+normlen*sample.x-p[0],
                            c[1]+normlen*sample.y-p[1]);
             rvec.normalize();
             ray = new Ray(new Vec(p[0], p[1]), rvec);
         }

         var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         line.setAttribute('x1',p[0]);
         line.setAttribute('y1',p[1]);
         tpt = ray.at(3.0*normlen);
         line.setAttribute('x2',tpt.x);
         line.setAttribute('y2',tpt.y);
         line.setAttribute("stroke", "black")
         line.setAttribute("stroke-linecap", "round");
         line.setAttribute("stroke-width", 0.5)
         overlay.appendChild(line);
     }
 }

 function Reflect()
 {
 }

 function Refract()
 {
     console.log("coming soon... _Refract!_");
 }

 function resizedw(){
     // Haven't resized in 100ms!
		 UpdateCanvasSize();
     ClearScene();
     GenerateScene();
 }

 ///////////////////////////////////////////////////////////////////////////////////
 // Below are the main UI control and SVG update functions.
 ///////////////////////////////////////////////////////////////////////////////////
 var key_presses = 0;
 var doit; // timer for window resize
 var selPt = null;
 var normlen_pct = 0.15;
 var k_pct = 0.30;
 var k_pct_sides = 0.10;
 var lines = new Array(3);
 var pt = new Array(4);
 var from_circle = false;
 var better_sampling = true;
 var nsamples = 100;
 $(document).ready(function() {

	   $("circle").on( "mousedown", function( event ) {
		     if ( ! selPt ) selPt = event.target;
	   });
	   $("circle").on( "mouseup", function( event ) {
		     selPt = null;
	   });
	   $(document).on( "mouseleave", function( event ) {
		     selPt = null;
	   });
	   $(document).on( "mousemove", function( event ) {
		     if ( selPt ) {
			       selPt.setAttribute("cx", event.clientX);
			       selPt.setAttribute("cy", event.clientY);
		     }
	   });
	   $(document).on( "keydown", function( event ) {
         const help = document.getElementById("keyboard_help");
         const state = document.getElementById("state");
         if ( key_presses == 0 ) {
             help.innerHTML = "nope. Try again.";
         } else if ( key_presses == 1 ) {
             help.innerHTML = "come on, you got this!";
         } else if ( key_presses == 2 ) {
             help.innerHTML = "Okay, fine. Press 'h' for help.";
         }
         if (key_presses >= 3) {
             var changed = false;
             switch (event.key) {
                 case 'c':
                     from_circle = !from_circle;
                     changed = true;
                     break;
                 case 'l':
                     better_sampling = !better_sampling;
                     changed = true;
                     break;
                 case 'r':
                     changed = true;
                     break;
                 case '+':
                 case '=':
                     nsamples *= 3.14159/2.0;
                     changed = true;
                     break;
                 case '-':
                     nsamples /= 3.14159/2.0;
                     changed = true;
                     break;
                 case 'h':
                     help.innerHTML = "'l' to toggle Lambertian<br>'c' to toggle source<br>'r' refresh<br>'+'/'-' inc/dec lines"
                     break;
                 default: help.innerHTML = "Press 'h' for help.";
             }

             state.innerHTML = "";
             if (better_sampling) state.innerHTML += "Lambertian";
             else                 state.innerHTML += "_cheap_ Lambertian";
             state.innerHTML += " *radiance* ";
             if (from_circle)     state.innerHTML += "from the center";
             else                 state.innerHTML += "from hit point";
             // else hemispherical, but not done so just putting a todo here rather than figuring out how to better show status
             if (changed) {
                 ClearScene();
                 GenerateScene();
             }
         }
         key_presses++;
     });
	   $(window).on( "resize", function( event ) {
         clearTimeout(doit);
         doit = setTimeout(resizedw, 100);
	   });
     InitCanvas();
     GenerateScene();
 });
 ///////////////////////////////////////////////////////////////////////////////////
</script>

// no idea what is different about div below and a <p> id here, or why the <p>id (haha) needs canvas
// oh! accidental discovery: it's just multiple things, canvas for the canvas, and #foo for that <p>id
// well, one problem is the <p> disappeared, going <div> -- which didn't help!
// no clue... and I was almost liking this html-css-js thing
// omfg: the comments were the killer. It's like the *want* to have bad code.

<style>
 html {
	   color: black;
	   background-color: white;
	   font-family: Arial;
	   overflow: hidden;
 }
 body {
	   padding: 0;
	   margin: 0;
 }
 canvas, #overlay {
	   display: block;
	   position: fixed;
	   top:  0;
	   left: 0;
	   width:  100%;
	   height: 100%;
     background: #a6c8ff;
 }
 #keyboard_help {
     font-family: Arial, Helvetica, sans-serif;
     color: gray;
     background: white;
     position: fixed;
     top: 0;
     left: 0;
     width: 25%;
     border: 3px solid #73AD21;
     padding: 2px;
 }
 #state {
     color: gray;
     background: white;
     position: fixed;
     top: 0;
     right: 0;
     width: 20%;
     border: 3px solid #73AD21;
     padding: 2px;
 }
 circle {
	   //fill: none;
	   stroke: black;
	   stroke-width: 1px;
	   //r: 5px;  // everyone or noone, not overridable
 }
 circle:hover {
	   fill: red;
	   cursor: hand;
	   stroke-width: 2px;
 }
 line {
	   stroke: black;
	   stroke-width: 2px;
	   //stroke-dasharray: 2, 20;
 }
 path {
	   stroke: green;
	   stroke-width: 2px;
	   stroke-dasharray: 2, 20;
	   fill: none;
 }
</style>

</head>
<body>
    <canvas id="canvas"></canvas>
    <svg id="overlay">
    </svg>
    <div id="keyboard_help">Press a key to change image.</div>
    <div id="state">artistic</div>
</body>
</html>
